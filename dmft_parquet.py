# simplified parquet equation DMFT solver for the one-band Hubbard model
# uses scipy, optimized on python 3.3.2
# Vladislav Pokorny; 2015-2017; pokornyv@fzu.cz

from sys import argv,exit,version_info
from os import listdir,remove
from time import ctime

import scipy as sp
from scipy.optimize import fixed_point,brentq
from scipy.interpolate import InterpolatedUnivariateSpline

from parlib import *
import params_dmft as p

method = 'SPE'
#method = '2nd'

# energy axis #######################################################
# RuntimeWarning: invalid value encountered in power: 
# for KK we need range(N)**3, for large arrays it can hit the limit of
# 9223372036854775808 == 2**63 of signed int, decrease number of energy points
N = 2**p.NE-1
dE_dec = int(-sp.log10(p.dE))
En_F = FillEnergies(p.dE,N)

hashes = '#'*80

ver = str(version_info[0])+'.'+str(version_info[1])+'.'+str(version_info[2])
if p.chat: 
	print(hashes+'\n# DMFT solver for one-band Hubbard model using simplified parquet equations')
	print('# generated by '+str(argv[0])+', python version: '+str(ver)+', SciPy version: '\
           +str(sp.version.version)+', '+str(ctime()))
	print('# U = {0: .4f}, Delta = {1: .4f}, eps = {2: .4f}, T = {3: .4f}'.format(p.U,p.Delta,p.ef,p.T))
	print('# energy axis: [{0: .5f} ..{1: .5f}], step = {2: .5f}, length = {3: 3d}'\
      .format(En_F[0],En_F[-1],p.dE,len(En_F)))
	print("# Kondo temperature Tk ~{0: .5f}".format(float(KondoTemperature(p.U,p.Delta,p.ef))))
	print("# mixing parameter alpha ={0: .5f}".format(float(p.alpha)))

	if   method == 'SPE': print("# using simplified parquet equation (SPE) solver")
	elif method == '2nd': print("# using 2nd-order PT solver")	

#####################################################################
# define the non-interacting DoS and allocate memory for arrays

if p.chat: print('# using semielliptic non-interacting DoS')
W = p.Delta # half-bandwidth for semielliptic DoS
GFlambda = lambda x: GreensFunctionSemi(x,W)
GFzero_F = GFlambda(En_F)

if p.chat: print('# norm[G0]: {0: .6f}, n[G0]: {1: .6f}'\
.format(float(IntDOS(GFzero_F,En_F)),float(Filling(GFzero_F,En_F,p.T))))

GFint_F = sp.copy(GFzero_F)
SE_F    = sp.zeros_like(GFzero_F)
SEold_F = sp.zeros_like(GFzero_F)

#####################################################################
# start DMFT loop 
LambdaOld = 1e5
for NLoop in range(p.NStart,p.NStart+p.NIter):
	if p.chat: print ('#\n'+'#'*40+'\n# DMFT iteration {0: 3d} /{1: 3d}'.format(NLoop,p.NStart+p.NIter-1))
	iter_file = open('iterations.dat','a')
	if NLoop == 1: 
		iter_file.write('# New calculation started on '+ctime()+'\n')
		iter_file.write('# iter\tLambda\t\ta\t\tDosInt\t\tDosF\t\tHWHM\t\tUc\t\tConv(Lambda)\n')

	# load data if necessary
	if p.NStart > 1 and NLoop == p.NStart:
		fname_in = 'dmft_'+str(NLoop-1)+'.npz'
		if p.chat: print('# loading interacting GF and self-energy from file')
		GFint_F = sp.load(fname_in)['GFint_F']
		try:                      
			SEold_F = sp.load(fname_in)['SE_F']
		except FileNotFoundError: 
			print('File not found, using zero self-energy.')
			SEold_F = sp.zeros_like(GFzero_F)
		try: 
			LambdaOld = sp.load(fname_in)['Lambda']
		except KeyError: 
			pass

	# calculate bath GF from lattice Dyson equation
	GFbath_F = 1.0/(1.0/GFint_F + SEold_F)
	#WriteFile(En_F,GFzero_F,GFbath_F,GFbath_F,U,Delta,en,0.0,1.0,p.WriteMax,p.WriteStep,'bath.dat',p.chat)

	# claculate the bubble
	if p.chat: print('# calculating the two-particle bubble...')
	Bubble_F = TwoParticleBubble(GFbath_F,GFbath_F,En_F,p.T,'eh')
	BubZero = Bubble_F[int(N/2)]
	Uc = -1.0/sp.real(BubZero)
	if p.chat: 
		print('# Bubble[0] = {0: .5f} + {1: .5f}i, critical U = {2: .5f}'\
		.format(float(sp.real(BubZero)),float(sp.imag(BubZero)),float(Uc)))

	# calculate Lambda part of the vertex
	if method == 'SPE':
		Lambda = CalculateLambda(p.U,Bubble_F,GFbath_F,GFbath_F,En_F,p.T,p.chat,p.epsl)
		if p.chat: print('# Lambda = {0: .5f}'.format(Lambda))
		a = 1.0 + Lambda*sp.real(BubZero)
		DLambda = sp.fabs(Lambda-LambdaOld)
		print('# Convergence: |Lambda - LambdaOld| ={0: .8f}'.format(DLambda))
		LambdaOld = Lambda
	else:
		Lambda = LambdaOld = DLambda = 0.0
		a = 1.0

	# calculate the self-energy from SD equation
	if p.chat: print('# calculating self-energy and the interacting Green function...')
	if method == 'SPE':
		K_F = KVertex(Lambda,Bubble_F)
		ChiDelta_F = p.U*Bubble_F*(K_F + Lambda)
	elif method == '2nd':
		ChiDelta_F = p.U**2*Bubble_F
	SE_F = SelfEnergy(GFbath_F,ChiDelta_F,En_F,p.T)

	# mix self-energy with previous iteration
	SE_F = (p.alpha*SE_F + (1.0-p.alpha)*SEold_F)
	SEold_F = sp.copy(SE_F)

	# calculate the interacting GF from local Dyson equation
	GFint_F = GFlambda(En_F-SE_F)
	DOSF = -sp.imag(GFint_F[int(N/2)])/sp.pi
	Norm = IntDOS(GFint_F,En_F)
	[HWHM,DOSmax,wmax] = CalculateHWHM(GFint_F,En_F)
	if p.chat: print('# Int A(w)dw (int) = {0: .5f}, DOS[0] = {1: .5f}, HWHM = {2: .6f}'\
	.format(float(Norm),float(DOSF),float(HWHM)))

	# write intermediate step to file
	if p.WriteFiles:
		filename = 'gf_iter'+str(NLoop)+'.dat'
		WriteFile(En_F,GFbath_F,SE_F,GFint_F,p.U,p.Delta,p.ef,p.WriteMax,p.WriteStep,'gf',filename,p.chat)
	# save int. GF and SE in case we want to continue iterations and remove an old one (npz files are large)
	sp.savez_compressed('dmft_'+str(NLoop),GFint_F = GFint_F, SE_F = SE_F, Lambda = Lambda)
	rm_filename = 'dmft_'+str(NLoop-2)+'.npz'
	if rm_filename in listdir('.'):
		print('# Removing npz file from iteration {0: 3d} to save disk space.'.format(NLoop-2))
		remove(rm_filename)
	# write data about current iteration fo file
	iter_file.write('{0: 3d}\t{1: .6f}\t{2: .6f}\t{3: .6f}\t{4: .6f}\t{5: .6f}\t{6: .6f}\t{7: .6f}\n'\
	.format(NLoop,Lambda,float(a),float(Norm),float(DOSF),float(HWHM),float(Uc),float(DLambda)))
	iter_file.close()

# write the final GF to file
filename = 'gf_U'+str(p.U)+'_dmft.dat'
WriteFile(En_F,GFbath_F,SE_F,GFint_F,p.U,p.Delta,p.ef,p.WriteMax,p.WriteStep,'gf',filename,p.chat)

print('{0: .3f}\t{1: .3f}\t{2: .3f}\t{3: .3f}\t{4: .6f}\t{5: .6f}\t{6: .6f}\t{7: .6f}\t{8: .6f}\t{9: .6f}\n'\
.format(p.U,p.Delta,p.ef,p.T,Lambda,float(a),float(Norm),float(DOSF),float(HWHM),float(DLambda)))

if p.chat: print('# '+argv[0]+' DONE.')

## dmft_parquet.py end ###

