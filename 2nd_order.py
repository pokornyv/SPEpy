# simplified parquet equation solver for SIAM
# calculating the 2nd order perturbation theory results
# uses either HF propagators or bare propagators as input
# generalized for the charge non-symmetric case
# uses scipy, optimized on python 3.5.2
# Vladislav Pokorny; 2015-2016; pokornyv@fzu.cz

import scipy as sp
from scipy.interpolate import InterpolatedUnivariateSpline,UnivariateSpline
from scipy.optimize import fixed_point,brentq
from sys import argv,exit,version_info
from time import ctime
from parlib import  *
import params_siam as p

method = '2nd'			# 2nd order perturbation
#method = 'eh-ladder'	# e-h horizontal ladder summation
#method = 'ee-ladder'	# e-e horizontal ladder summation

sc_2nd = 'hf'
#sc_2nd = 'none'

selfconsistent = True

U     = float(argv[1])
Delta = float(argv[2])
en    = float(argv[3])
T     = float(argv[4])

ed = en-U/2.0 # shift energy level so en = 0 represents half-filling

## energy axis ############################################
if p.NE>21:
	print('# Warning: too many points on the real axis can cause failure in calculation of the Kramers-Kronig relations!')
# RuntimeWarning: invalid value encountered in power:
# for KK we need range(N)**3, for large arrays it can 
# hit the limit of 9223372036854775808 == 2**63 of signed int
# decrease number of energy points
N = 2**p.NE-1
dE_dec = int(-sp.log10(p.dE))
En_F = FillEnergies(p.dE,N)

ver = str(version_info[0])+'.'+str(version_info[1])+'.'+str(version_info[2])
if p.chat: 
	print ('# generated by '+str(argv[0])+', python version: '+str(ver)+', SciPy version: '\
           +str(sp.version.version)+', '+str(ctime()))
	print('# U = {0: .4f}, Delta = {1: .4f}, eps = {2: .4f}'.format(U,Delta,en))
	print('# energy axis: [{0: .5f} ..{1: .5f}], step = {2: .5f}, length = {3: 3d}'\
      .format(En_F[0],En_F[-1],p.dE,len(En_F)))

if p.chat: print("# Kondo temperature Tk ~{0: .5f}".format(float(KondoTemperature(U,Delta,en))))

if method == '2nd':			# 2nd order perturbation
	if p.chat: print('# Using vertex from 2nd order perturbation theory')
elif method == 'eh-ladder':	# RPA
	if p.chat: print('# Using vertex from eh-ladder summation ("RPA")')
elif method == 'ee-ladder':	# TMA
	if p.chat: print('# Using vertex from ee-ladder summation ("TMA")')
else:
	print('Error: Unknown method')
	exit(1)

if p.GFtype == 'semi':
	if p.chat: print('# using semielliptic non-interacting DoS')
	W = Delta
	GFlambda = lambda x: GreensFunctionSemi(x,W)
	n_density = lambda x: DensitySemi(ed+U*x,W)
elif p.GFtype == 'lor':
	if p.chat: print('# using Lorentzian non-interacting DoS')
	GFlambda = lambda x: GreensFunctionLorenz(x,Delta)
	n_density = lambda x: DensityLorentz(ed+U*x,Delta)
elif p.GFtype == 'gauss':
	if p.chat: print('# using Gaussian non-interacting DoS')
	GFlambda = lambda x: GreensFunctionGauss(x,Delta)
	n_density = lambda x: DensityGauss(ed+U*x,Delta)
else:
	print('# unknown nonint. DoS.')
	exit()

if T != 0.0: 	
	n_density = lambda x: Filling(GFlambda(En_F-(ed+U*x)),En_F,T)
n = fixed_point(n_density,0.5)

## choose level of the charge self-consistency
if sc_2nd == 'hf':
	## 2nd order PT with HF dressed propagators as input
	hfe = ed+U*n
	GFzeroP_F = GFlambda(En_F-hfe)
	GFzeroH_F = GFlambda(En_F-hfe)
elif sc_2nd == 'none':
	## pure 2nd order PT with bare propagators as input
	hfe = ed+U/2.0
	GFzeroP_F = GFlambda(En_F-hfe)
	GFzeroH_F = GFlambda(En_F-hfe)
	n = Filling(GFzeroP_F,En_F,T)
	hfe = ed+U*n
else:
	print('# Wrong self-consistency switch value.')
	exit()

if p.chat: print('# Int A(w)dw (nonint): {0: .5f}, filling (nonint): {1: .5f}'\
.format(float(IntDOS(GFzeroP_F,En_F)),Filling(GFzeroP_F,En_F,T)))

if p.chat: print('# calculating the two-particle bubble...')
if method in ['2nd','eh-ladder']:
	Bubble_F = TwoParticleBubble(GFzeroP_F,GFzeroH_F,En_F,T,'eh') # Bubble[0] is negative
else:	# ee-ladder
	Bubble_F = TwoParticleBubble(GFzeroP_F,GFzeroP_F,En_F,T,'ee') # Bubble[0] is positive
BubZero = Bubble_F[int(N/2)]
Uc = -1.0/sp.real(BubZero)
if p.chat: print('# Bubble[0] = {0: .5f} + {1: .5f}i'\
               .format(float(sp.real(BubZero)),float(sp.imag(BubZero))))
if p.chat: print('# Critical U = {0: .5f}'.format(float(Uc)))

#WriteFile(En_F,GFzeroP_F,Bubble_F,Bubble_F,U,Delta,en,p.WriteMax,p.WriteStep,'gf','2nd_bub.dat',p.chat)

if p.chat: print('# calculating spectral function...')
if method == '2nd':
	ChiGamma_F = U**2*Bubble_F
elif method == 'eh-ladder':
	ChiGamma_F = U**2*Bubble_F/(1.0+U*Bubble_F)
elif method == 'ee-ladder':
	ChiGamma_F = -U**2*Bubble_F/(1.0+U*Bubble_F)

SE_F = SelfEnergy(GFzeroH_F,ChiGamma_F,En_F,T)

#GFint_F = GFlambda(En_F-hfe-SE_F)

if selfconsistent:
	if p.chat: print('# iterating the final density n=fx[G(n)]...')
	n_density = lambda x: Filling(GFlambda(En_F-(ed+U*x)-SE_F),En_F,T)
	n = fixed_point(n_density,0.5)
	hfe = ed+U*n
GFint_F = GFlambda(En_F-hfe-SE_F)

Ne = Filling(GFint_F,En_F,T)

## quasiparticle weight ###################################
[Z,dReSEdw] = QuasiPWeight(En_F,sp.real(SE_F))

## Kondo scale ############################################
DOSF = -sp.imag(GFint_F[int(N/2)])/sp.pi
a = 1.0
Lambda = 1.0

## HWHM ###################################################
[HWHM,DOSmax,wmax] = CalculateHWHM(GFint_F,En_F)

IntMin = int((N+1)/2-int(0.5/p.dE)) # +0.5 helps for small U
#IntMax = int((N+1)/2+int(0.5/p.dE))
#DOSmaxPos = sp.argmax(-sp.imag(GFint_F[IntMin:IntMax])/sp.pi)
#DOSmax    = -sp.imag(GFint_F[IntMin+DOSmaxPos])/sp.pi
#wmax      = En_F[IntMin+DOSmaxPos]
#DOS = InterpolatedUnivariateSpline(En_F,-sp.imag(GFint_F)/sp.pi-DOSmax/2.0)
#DOSroots_F = sp.sort(sp.fabs(DOS.roots()))
#HWHM = (DOSroots_F[0] + DOSroots_F[1])/2.0

if p.chat: print('# Int A(w)dw (int) = {0: .5f}, DOS[0] = {1: .5f}, filling = {2: .5f}'\
               .format(float(IntDOS(GFint_F,En_F)),float(DOSF),float(Ne)))
if p.chat: print('# Z = {0: .5f}, DReSE/dw[0] = {1: .5f}, m*/m = {2: .5f}'\
               .format(float(Z),float(dReSEdw),float(1.0/Z)))
if p.chat: print('# a = {0: .5f}, exp(-U DOS[0]) = {1: .5f}, HWHM = {2: .5f}'\
               .format(float(a),float(sp.exp(-U*DOSF)),float(HWHM)))

print('{0: .3f}\t{1: .3f}\t{2: .3f}\t{3: .5f}\t{4: .5f}\t{5: .5f}\t{6: .5f}'\
      .format(U,en,T,Ne,float(DOSF),float(Z),float(HWHM)))
#print('{0: .3f}\t{1: .6f}\t{2: .6f}\t{3: .6f}'.format(U,float(HWHM),float(Z),float(KondoTemperature(U,Delta,en))))

if p.WriteGF:
	if p.chat: print('# writing the output files...')
	if p.WriteMax > sp.fabs(En_F[0]): p.WriteMax = sp.fabs(En_F[0]) # cannot write data outside the frequency window
	filename = 'gf_'+method+'_'+p.GFtype+'_U'+str(U)+'eps'+str(en)+'T'+str(T)+'.dat'
	header = '# E\t\t\tRe GF0\t\tIm GF0\t\tRe SE\t\tIm SE\t\tRe GF\t\tIm GF\n'
	WriteFile(En_F,GFzeroP_F,SE_F,GFint_F,U,Delta,en,p.WriteMax,p.WriteStep,header,filename,p.chat)

if p.chat: print('# '+argv[0]+' DONE.')

## 2nd_order.py end ##

