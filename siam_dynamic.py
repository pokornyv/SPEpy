# simplified parquet equation solver for SIAM
# generalized for frequency-dependent Lambda vertex
# uses scipy, optimized on python 3.5.2 and SciPy 0.18
# Vladislav Pokorny; 2015-2017; pokornyv@fzu.cz

import scipy as sp
from scipy.integrate import simps
from sys import argv,exit,version_info
from os import listdir
from time import ctime,time
from parlib import *
import params_siam as p

t = time()

U      = float(argv[1])
Delta  = float(argv[2])
ed     = float(argv[3])
try:
	inU  = float(argv[4])
	InFile = True
except IndexError:
	InFile  = False

T = 0.0
izero = 1e-6

# energy axis #############################################
# RuntimeWarning: invalid value encountered in power: 
# for KK we need range(N)**3, for large arrays it can hit the limit of
# 9223372036854775808 == 2**63 of signed int, decrease number of energy points
N = 2**p.NE-1
dE_dec = int(-sp.log10(p.dE))
En_F = FillEnergies(p.dE,N)

hashes = '#'*80

## print the header #######################################
ver = str(version_info[0])+'.'+str(version_info[1])+'.'+str(version_info[2])
if p.chat: 
	print (hashes+'\n# generated by '+str(argv[0])+', python version: '+str(ver)+', SciPy version: '\
           +str(sp.version.version)+', '+str(ctime()))
	print('# energy axis: [{0: .5f} ..{1: .5f}], step = {2: .5f}, length = {3: 3d}'\
      .format(En_F[0],En_F[-1],p.dE,len(En_F)))
	print('# U = {0: .4f}, Delta = {1: .4f}, ed = {2: .4f}, T = {3: .4f}'.format(U,Delta,ed,T))
	print("# Kondo temperature from Bethe ansatz: Tk ~{0: .5f}".format(float(KondoTemperature(U,Delta,ed))))

## inicialize the non-interacting Green function ##########
if p.GFtype == 'lor':
	if p.chat: print('# using Lorentzian non-interacting DoS')
	GFlambda = lambda x: GreensFunctionLorenz(x,Delta)
	DensityLambda = lambda x: DensityLorentz(x,Delta)
elif p.GFtype == 'semi':
	if p.chat: print('# using semielliptic non-interacting DoS')
	W = Delta # half-bandwidth 
	GFlambda = lambda x: GreensFunctionSemi(x,W)
	DensityLambda = lambda x: DensitySemi(x,W)
elif p.GFtype == 'gauss':
	if p.chat: print('# using Gaussian non-interacting DoS')
	GFlambda = lambda x: GreensFunctionGauss(x,Delta)
	DensityLambda = lambda x: DensityGauss(x,Delta)
elif p.GFtype == 'sc':
	if p.chat: print('# using simple cubic lattice non-interacting DoS')
	W = Delta # half-bandwidth 
	GFlambda = lambda x: GreensFunctionSC(x,W)
elif p.GFtype == 'sq':
	if p.chat: print('# using square lattice non-interacting DoS')
	W = Delta # half-bandwidth 
	GFlambda = lambda x: GreensFunctionSquare(x,izero,W)
else:
	print('# Error: DoS not implemented.')
	exit(1)

if p.chat: print('# filling the array with the non-interacting Green function:')
if p.GFtype in ['sc','sq']:
	fin = p.GFtype+'_gf_'+str(W)+'_'+str(p.NE)+'_'+str(p.dE)+'.npz'
	try:
		GFzero_F = sp.load(fin)['GFzero_F']
		i2 = sp.load(fin)['izero']
		if i2 == izero:
			if p.chat: print('# - reading non-interacting GF from file '+fin)
		else: 
			print('- i0 value differs from the saved data')
			raise FileNotFoundError()
	except FileNotFoundError:
		if p.chat: print('# - file '+fin+' not found, or i0 differs, generating new file')
		t = time()
		GFzero_F = GFlambda(En_F)
		GFzero_F = GFzero_F/IntDOS(GFzero_F,En_F)
		sp.savez_compressed(fin, En_F = En_F, GFzero_F = GFzero_F, izero = izero)
		if p.chat: print('# - file generated in '+str(int(time()-t))+' seconds.')
else:		
	GFzero_F = GFlambda(En_F)
	GFzero_F = GFzero_F/IntDOS(GFzero_F,En_F)
#WriteFile(En_F,GFzero_F,GFzero_F,GFzero_F,U,Delta,ed,p.WriteMax,p.WriteStep,'gf','GFzero.dat',p.chat)
if p.chat: print('# - norm[G0]: {0: .6f}, n[G0]: {1: .6f}'\
.format(float(IntDOS(GFzero_F,En_F)),float(Filling(GFzero_F,En_F,T))))

## calculating the charge-symmetric case (n=0.5) to get L0(w)
if p.chat: print('#\n# calculating the charge-symmetric solution:')

# calculating the static Lambda as a starting point
if p.chat: print('# calculating the static Lambda vertex for comparison:')
Bubble_F = TwoParticleBubble(GFzero_F,GFzero_F,En_F,T,'eh') # Bubble[0] is negative
LambdaStatic = CalculateLambda(U,Bubble_F,GFzero_F,GFzero_F,En_F,T,p.chat,p.epsl)
#K_F = -LambdaStatic**2*Bubble_F/(1.0+LambdaStatic*Bubble_F+1e-12)
if p.chat: print('# - static Lambda = {0: .6f}'.format(LambdaStatic))

n = 0.5	# fixed filling
Lambda_F  = U*sp.ones(len(GFzero_F))	# initial condition for L(w)
GFtherm_F = sp.copy(GFzero_F)

## loading vertex from calculation with smaller U  as an initial condition
if InFile:
	datafile = 'data_'+str(p.GFtype)+'_U'+str(inU)+'.npz'	# compressed data file
	if datafile not in listdir('.'): 
		print('# - Error: File '+datafile+' does not exist. Exit.')
		exit(1)
	if p.chat: print('# Loading vertex function from calculation for U='+str(inU)+' as an initial condition:')
	En2_F     = sp.load(datafile)['En_F']
	Lambda_F  = sp.load(datafile)['Lambda_F']
	K_F       = sp.load(datafile)['K_F']
	GFtherm_F = sp.load(datafile)['GFtherm_F']	
	if len(En_F) != len (En2_F):
		print('# - Error: Diffrent energy axis in input file, exit.')
		exit()
	#Lambda_F = Lambda_F - inU + U	# shift to correct asymptotics
	if p.chat: print('# - Lambda[0] = {0: .6f}'.format(Lambda_F[int(N/2)]))

LambdaZero = Lambda_F[int(N/2)]	# Lambda at Fermi energy, convergence test
LambdaZeroOld = 1e8
eps = 1e-4	# convergence criterium
if p.chat: print('#\n# calculating the dynamical Lambda vertex:')
if p.chat: print('# - mixing factor alpha = {0: .4f}'.format(p.alpha))
k = 1
while any([sp.fabs(sp.real(LambdaZero-LambdaZeroOld))>eps]):
	LambdaZeroOld = LambdaZero
	LambdaOld_F = Lambda_F
	K_F = KVertexDynamic(Lambda_F,GFtherm_F,GFtherm_F,En_F,T)
	Lambda_F = LVertexDynamic(K_F,GFtherm_F,GFtherm_F,En_F,U,T)
	LambdaZero = Lambda_F[int(N/2)]
	SEtherm_F = SelfEnergy(GFtherm_F,Lambda_F,En_F,T)
	GFtherm_F = GFlambda(En_F-ed-U*(n-0.5)-SEtherm_F)
	if False:
		LGG_F = TwoParticleBubble(Lambda_F*GFtherm_F,GFtherm_F,En_F,T,'eh')
		KGG_F = TwoParticleBubble(sp.conj(K_F)*GFtherm_F,GFtherm_F,En_F,T,'ee')
		header = '# E\t\t\tRe Lambda\t\tIm Lambda\t\tRe K\t\tIm K\t\tRe <KGG>\t\tIm <KGG>\t\tRe <LGG>\t\tIm <LGG>\n'
		WriteFile2(En_F,Lambda_F,K_F,LGG_F,KGG_F,U,Delta,ed,p.WriteMax,p.WriteStep,header,'vertex'+str(k)+'.dat',p.chat)
	#WriteFile(En_F,Lambda_F,K_F,Lambda_F+K_F,U,Delta,ed,p.WriteMax,p.WriteStep,'','vertex'+str(k)+'.dat',p.chat)
	#WriteFile(En_F,GFtherm_F,SEtherm_F,GFzero_F,U,Delta,ed,p.WriteMax,p.WriteStep,'','dyn_green.dat'+str(k),p.chat)	
	if p.chat: print('# - iteration {0: 3d}: norm[GT] = {1: .6f}, nT = {2: .6f}, LambdaZero = {3: .6f} {4:+.6f}i'\
	.format(int(k),float(IntDOS(GFtherm_F,En_F)),float(Filling(GFtherm_F,En_F,T))\
	,float(sp.real(LambdaZero)),float(sp.imag(LambdaZero))))
	Lambda_F = p.alpha*Lambda_F+(1.0-p.alpha)*LambdaOld_F
	k += 1
	if k > 1000:
		print('# - no convergence after 1000 iterations, exit.')
		exit(1)

LambdaZero = Lambda_F[int(N/2)]
nT = Filling(GFtherm_F,En_F,T)
if p.chat: print('# - Lambda[0] = {0: .6f}, norm[GT] = {1: .6f}, nT = {2: .6f}'\
.format(LambdaZero,float(IntDOS(GFtherm_F,En_F)),float(nT)))

## testing the convolutions
#BubbleEH_F = TwoParticleBubble(GFzero_F,GFzero_F,En_F,T,'eh')
#BubbleEE_F = TwoParticleBubble(GFzero_F,GFzero_F,En_F,T,'ee')
#WriteFile(En_F,GFzero_F,BubbleEH_F,BubbleEE_F,U,Delta,ed,p.WriteMax,p.WriteStep,'','bubbles.dat',p.chat)

## calculate the spectral self-energy and Green function ##
LGG_F = TwoParticleBubble(Lambda_F*GFtherm_F,GFtherm_F,En_F,T,'eh')
Kernel_F = U*LGG_F/(1.0+LGG_F)
SE_F = SelfEnergy(GFtherm_F,Kernel_F,En_F,T)
GFint_F = GFlambda(En_F-ed-U*(n-0.5)-SE_F)

n = Filling(GFint_F,En_F,T)
if p.chat: print('# - ed = {0: .6f}: norm[Gint] = {1: .6f}, n[Gint] = {2: .6f}'.format(ed,float(IntDOS(GFint_F,En_F)),float(n)))

## quasiparticle weight ###################################
[Z,dReSEdw] = QuasiPWeight(En_F,sp.real(SE_F))
if p.chat: print('# - Z = {0: .6f}, DReSE/dw[0] = {1: .6f}, m*/m = {2: .6f}'\
.format(float(Z),float(dReSEdw),float(1.0/Z)))

## DoS at Fermi energy ####################################
DOSF = -sp.imag(GFint_F[int(N/2)])/sp.pi

## Kondo scale from Lambda ################################
a = 1.0 + sp.real(TwoParticleBubble(Lambda_F*GFtherm_F,GFtherm_F,En_F,T,'eh')[int(N/2)])

## HWHM ###################################################
[HWHM,DOSmax,wmax] = CalculateHWHM(GFint_F,En_F)
if HWHM == 0.0 and p.chat: print('# Warning: HWHM cannot be calculated, setting it to zero.')
if HWHM < p.dE and HWHM != 0.0: print('# - Warning: HWHM smaller than energy resolution.')

if p.chat: print('# - DOS[0] = {0: .6f}, maximum of DoS: {1: .6f} at w = {2: .6f}'.format(float(DOSF),float(DOSmax),float(wmax)))
if p.chat: print('# - Kondo scales: a = {0: .6f}, exp(-U DOS[0]) = {1: .6f}, HWHM = {2: .6f}'\
.format(float(a),float(sp.exp(-U*DOSF)),float(HWHM)))
if HWHM < p.dE and HWHM != 0.0: print('# - Warning: HWHM smaller than energy resolution.')

print('{0: .4f}\t{1: .6f}\t{2: .6f}\t{3: .6f}\t{4: .6f}\t{5: .6f}'\
.format(float(U),float(sp.real(LambdaZero)),float(sp.real(LambdaStatic)),float(Z),float(HWHM),float(a)))

if p.chat: print('# writing the output files:')
if p.WriteGF:
	filename = 'gfdyn_'+str(p.GFtype)+'_U'+str(U)+'.dat'
	header = '# E\t\t\tRe SEtherm\t\tIm SEtherm\t\tRe GFtherm\t\tIm GFtherm\t\tRe SE\t\tIm SE\t\tRe GF\t\tIm GF\n'
	WriteFile2(En_F,SEtherm_F,GFtherm_F,SE_F,GFint_F,U,Delta,ed,p.WriteMax,p.WriteStep,header,filename,p.chat)
if p.WriteVertex:
	filename = 'vertexdyn_'+str(p.GFtype)+'_U'+str(U)+'.dat'
	header = '# E\t\t\tRe Lambda\t\tIm Lambda\t\tRe K\t\tIm K\t\tRe SD-kernel\t\tIm SD-kernel\n'
	WriteFile(En_F,Lambda_F,K_F,Kernel_F,U,Delta,ed,p.WriteMax,p.WriteStep,header,filename,p.chat)
if p.WriteNpz:
	datafile = 'data_'+str(p.GFtype)+'_U'+str(U)+'.npz'	# compressed data file
	sp.savez_compressed(datafile, En_F = En_F, Lambda_F = Lambda_F, K_F = K_F, GFtherm_F = GFtherm_F)
	if p.chat: print('# File '+datafile+' written.')

if p.chat: print('# '+argv[0]+' DONE after {0: .2f} seconds.'.format(float(time()-t)))

## siam_parquet.py end ###

