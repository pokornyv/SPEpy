######################################################################
# SPEpy - simplified parquet equation solver for SIAM                #
# Copyright (C) 2019  Vladislav Pokorny; pokornyv@fzu.cz             #
# homepage: github.com/pokornyv/SPEpy                                #
# siam_static.py - solver for SPE                                    #
# method described in PRB 95, 165113 (2017)., PRB 95, 045108 (2017). #
######################################################################

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import scipy as sp
from scipy.optimize import brentq
from sys import argv,exit,version_info
from time import ctime,time
from parlib import *
#from config_siam import *

t = time()

izero = 1e-6

hashes = '#'*80

## print the header #######################################
ver = str(version_info[0])+'.'+str(version_info[1])+'.'+str(version_info[2])
if chat: 
	print(hashes+'\n# generated by '+str(argv[0])+', python version: '+str(ver)+', SciPy version: '\
           +str(sp.version.version)+', '+str(ctime()))
	print('# energy axis: [{0: .5f} ..{1: .5f}], step = {2: .5f}, length = {3: 3d}'\
      .format(En_A[0],En_A[-1],dE,len(En_A)))
	print('# U = {0: .4f}, Delta = {1: .4f}, ed = {2: .4f}, T = {3: .4f}'.format(U,Delta,ed,T))
	print("# Kondo temperature Tk ~{0: .5f}".format(float(KondoTemperature(U,Delta,ed))))

## inicialize the non-interacting Green function ##########
if GFtype == 'lor':
	if chat: print('# using Lorentzian non-interacting DoS')
	GFlambda = lambda x: GreensFunctionLorenz(x,Delta)
	DensityLambda = lambda x: DensityLorentz(x,Delta)
elif GFtype == 'semi':
	if chat: print('# using semielliptic non-interacting DoS')
	W = Delta ## half-bandwidth 
	GFlambda = lambda x: GreensFunctionSemi(x,W)
	DensityLambda = lambda x: DensitySemi(x,W)
elif GFtype == 'gauss':
	if chat: print('# using Gaussian non-interacting DoS')
	GFlambda = lambda x: GreensFunctionGauss(x,Delta)
	DensityLambda = lambda x: DensityGauss(x,Delta)
elif GFtype == 'cubic':
	if chat: print('# using simple cubic lattice non-interacting DoS')
	W = Delta ## half-bandwidth 
	GFlambda = lambda x: GreensFunctionSC(x,W)
elif GFtype == 'square':
	if chat: print('# using square lattice non-interacting DoS')
	W = Delta ## half-bandwidth 
	GFlambda = lambda x: GreensFunctionSquare(x,izero,W)
else:
	print('# Error: DoS not implemented.')
	exit(1)

if chat: print('# filling the array with the non-interacting Green function...')
if GFtype in ['cubic','square']:
	fin = GFtype+'_gf_'+str(W)+'_'+str(NE)+'_'+str(dE)+'.npz'
	try:
		GFzero_A = sp.load(fin)['GFzero_A']
		i2 = sp.load(fin)['izero']
		if i2 == izero:
			if chat: print('# - reading non-interacting GF from file '+fin)
		else: 
			print('- i0 value differs from the saved data')
			raise FileNotFoundError()
	except FileNotFoundError:
		if chat: print('# - file '+fin+' not found, or i0 differs, generating new file')
		t = time()
		GFzero_A = GFlambda(En_A)
		GFzero_A = GFzero_A/IntDOS(GFzero_A)
		sp.savez_compressed(fin, En_A = En_A, GFzero_A = GFzero_A, izero = izero)
		if chat: print('# - file generated in '+str(int(time()-t))+' seconds.')
else:		
	GFzero_A = GFlambda(En_A)
	GFzero_A = GFzero_A/IntDOS(GFzero_A)
#WriteFileX([GFzero_A,GFzero_A,GFzero_A],WriteMax,WriteStep,'gf','GFzero.dat')

## calculating the charge-symmetric case (n=0.5) to get Lambda0
if chat: print('#\n# calculating the charge-symmetric solution:')
if chat: print('# norm[G0]: {0: .6f}, n[G0]: {1: .6f}'\
.format(float(IntDOS(GFzero_A)),float(Filling(GFzero_A))))

if chat: print('# calculating the charge-symmetric two-particle bubble...')
Bubble_A = TwoParticleBubble(GFzero_A,GFzero_A,'eh') # Bubble[0] is negative
BubZero = Bubble_A[int(N/2)]
Uc = -1.0/sp.real(BubZero)
if chat: print('# - Bubble[0] = {0: .6f},   critical U = {1: .6f}'.format(BubZero,Uc))
if chat: print('# calculating the charge-symmetric Lambda vertex...')
Lambda = CalculateLambda(Bubble_A,GFzero_A,GFzero_A)
if chat: print('# - Lambda = {0: .6f}'.format(Lambda))

SigmaT = SigmaT_old = -ed
GFtherm_A = sp.copy(GFzero_A)
nT = 0.5
k = 1
## calculating the non-charge-symmetric case ##############
if ed!=0.0:
	nTold = 1e5
	Lambdaold = 1e5
	if chat: print('#\n# calculating the non-symmetric solution:')
	if chat: print('# iterating the thermodynamic self-energy SigmaT, mixing: alpha = {0: .3f}:'\
	.format(float(alpha)))
	while any([sp.fabs(nT-nTold)>epst,sp.fabs(SigmaT-SigmaT_old)>epst]):
		nTold = nT
		Lambdaold = Lambda
		SigmaT_old = SigmaT
		if GFtype in ['cubic','square']: GFtherm_A = ShiftGreensFunction(GFzero_A,-ed-SigmaT)
		else:                     GFtherm_A = GFlambda(En_A-ed-SigmaT)
		Bubble_A = TwoParticleBubble(GFtherm_A,GFtherm_A,'eh') # Bubble[0] is negative
		Lambda = CalculateLambda(Bubble_A,GFtherm_A,GFtherm_A)
		## calculate nT ###################################
		if GFtype in ['cubic','square']:
			eq = lambda x: Filling(ShiftGreensFunction(GFzero_A,-ed-Lambda*(x-0.5))) - x
		else:
			if T == 0.0: ## zero-temperature data can be calculated more precisely
				eq = lambda x: DensityLambda(ed+Lambda*(x-0.5)) - x
			else: ## finite temperature
				eq = lambda x: Filling(GFlambda(En_A-ed-Lambda*(x-0.5))) - x
		try:
			nT = brentq(eq,0.0,1.0,xtol = epst)
		except ValueError:	
			## we have full or empty band, it can cause "f(a) and f(b) must have different signs" error
			print('# Warning: nT cannot be evaluated, assuming full/empty band')
			nT = 0.0 if ed > 0.0 else 1.0
		## calculate SigmaT ###############################
		SigmaT = Lambda*(nT-0.5)
		if chat: print('# - iteration {0: 3d}: norm[GTin] = {1: .6f}, n[GTin] = {2: .6f}, Lambda = {3: .6f}, nT = {4: .6f}, SigmaT = {5: .6f}'\
		.format(int(k),float(IntDOS(GFtherm_A)),float(Filling(GFtherm_A)),Lambda,float(nT),float(SigmaT)))
		k+=1
		SigmaT = alpha*SigmaT+(1.0-alpha)*SigmaT_old	# mix iterations, useful far away from half-filling
	if chat: print('# Calculation of SigmaT finished after {0: 3d} iterations.'.format(int(k-1)))

## recalculate the thermodynamic Green function and bubble, just in case
if GFtype in ['cubic','square']: GFtherm_A = ShiftGreensFunction(GFzero_A,-ed-SigmaT)
else:                     GFtherm_A = GFlambda(En_A-ed-SigmaT)
Bubble_A = TwoParticleBubble(GFtherm_A,GFtherm_A,'eh')
BubZero = Bubble_A[int(N/2)]
Lambda = CalculateLambda(Bubble_A,GFtherm_A,GFtherm_A)
if chat: print('# final parameters: Bubble[0] = {0: .6f}, Lambda = {1: .6f}, nT = {2: .6f}, SigmaT = {3: .6f}, muBar = {4: .6f}'\
.format(BubZero,Lambda,float(nT),float(SigmaT),float(-SigmaT-ed)))

## calculate the spectral self-energy and Green function ##
if chat: print('#\n# calculating the spectral self-energy...')
K_A = KVertex(Lambda,Bubble_A)
ChiGamma_A = U*Bubble_A*(K_A + Lambda)
SE_A = SelfEnergy(GFtherm_A,ChiGamma_A)

## quasiparticle weight ###################################
[Z,dReSEdw] = QuasiPWeight(sp.real(SE_A))

if chat: print('# - Z = {0: .6f}, DReSE/dw[0] = {1: .6f}, m*/m = {2: .6f}'\
.format(float(Z),float(dReSEdw),float(1.0/Z)))

## calculating interacting Green function #################
if chat: print('# calculating the spectral function and final filling')
## method to calculate the interacting Green function, H - local GF, S - lattice GF  
GFmethod = 'H'
#if GFmethod == "H": ## this is the local GF as a sum over the Brillouin zone
if ed!=0.0:
	if chat: print('# iterating the final density n=fx[G(n)]...')
	eq = lambda x: x - Filling(GFlambda(En_A-ed-U*(x-0.5)-SE_A))
	n = brentq(eq,0.0,1.0,xtol = epsn)
else: n = 0.5
GFint_A = GFlambda(En_A-ed-U*(n-0.5)-SE_A)
#else: ## this calculates the lattice Green function from the Dyson equation
#	if ed!=0.0:
#		if chat: print('# iterating the final density n=fx[G(n)]...')
#		eq = lambda x: x - Filling(1.0/(1.0/GFtherm_A-U*(x-0.5)-SE_A))
#		n = brentq(eq,0.0,1.0,xtol = epsn)
#	else: n = 0.5
#	GFint_A = 1.0/(1.0/GFtherm_A-U*(n-0.5)-SE_A)

n = Filling(GFint_A)
if chat: print('# - ed = {0: .6f}: norm[Gint] = {1: .6f}, n[Gint] = {2: .6f}'.format(ed,float(IntDOS(GFint_A)),float(n)))

'''
## non-local susceptibilities #############################
muBar = -(SigmaT+ed)
DoSmuBar = -sp.imag(GFlambda(muBar))/sp.pi
AFBubble = AFbubble(En_A,GFzero_A,muBar)
FBubble  = -DoSmuBar
print('{0: .3f}\t{1: .4f}\t{2: .3f}\t{3: .5f}\t{4: .5f}\t{5: .8f}\t{6: .8f}\t{7: .8f}\t{8: .8f}'\
.format(float(U),float(ed),float(T),float(n),float(nT),float(AFBubble),float(FBubble),float(1.0+Lambda*AFBubble),float(1.0+Lambda*FBubble)))
exit()
'''

## DoS at Fermi energy ####################################
DOSF = -sp.imag(GFint_A[int(N/2)])/sp.pi

## Kondo scale from Lambda ################################
a = 1.0 + Lambda*sp.real(BubZero)

## HWHM ###################################################
[HWHM,DOSmax,wmax] = CalculateHWHM(GFint_A)
if HWHM == 0.0 and chat: print('# - Warning: HWHM cannot be calculated, setting it to zero.')
if HWHM < dE and HWHM != 0.0: print('# - Warning: HWHM smaller than energy resolution.')

if chat: print('# - DOS[0] = {0: .6f}, maximum of DoS: {1: .6f} at w = {2: .6f}'\
.format(float(DOSF),float(DOSmax),float(wmax)))
if chat: print('# - Kondo scales: a = {0: .6f}, exp(-U DOS[0]) = {1: .6f}, HWHM = {2: .6f}'\
.format(float(a),float(sp.exp(-U*DOSF)),float(HWHM)))

## susceptibilities #######################################
if calcSusc:
	if chat: print('# calculating susceptibilities:')
	[X1_A,X2_A,X3_A] = XIntegralsFFT(GFtherm_A,Bubble_A,Lambda,BubZero)
	X_A = X1_A+X2_A+X3_A
	XT = SusceptibilityTherm(a,GFtherm_A)
	XS = SusceptibilitySpec(U,Lambda,X_A,GFint_A,BubZero)
	XH = SusceptibilityHF(U,GFint_A,X_A)

	if chat: print('# - Thermal  susceptibility: XT = {0: .5f}\n\
# - Spectral susceptibility: XS = {1: .5f}\n\
# - Hartree  susceptibility: XH = {2: .5f}'.format(float(XT),float(XS),float(XH)))
else:
	if chat: print('# susceptibilities are not calculated')
	XT = XS = XH = 0.0

print('{0: .3f}\t{1: .3f}\t{2: .4f}\t{3: .5f}\t{4: .5f}\t{5: .5f}\t{6: .5f}\t\
{7: .6f}\t{8: .6f}\t{9: .6f}\t{10: .5f}\t{11: .5f}\t{12: .5f}'\
.format(U,ed,T,nT,n,Lambda,float(a),float(DOSF),float(Z),float(HWHM),float(XT),float(XS),float(XH)))

## write the outputs ######################################
if any([WriteGF,WriteVertex,WriteNpz]):
	if chat: print('# writing the output files:')
	ed = sp.around(ed,3)
	#if calcSusc:
	#	filename = 'X_'+GFtype+'_U'+str(U)+'.dat'
	#	header = '# E\t\t\tRe X1\t\tIm X1\t\tRe X2\t\tIm X2\t\tRe X3\t\tIm X3\n'
	#	WriteFileX([X1_A,X2_A,X3_A],WriteMax,WriteStep,header,filename)
	if WriteGF:
		filename = 'gf_'+str(GFtype)+'_U'+str(U)+'eps'+str(ed)+'T'+str(T)+'.dat'
		header = '# E\t\tRe GF0\t\tIm GF0\t\tRe SE\t\tIm SE\t\tRe GF\t\tIm GF'
		WriteFileX([GFtherm_A,SE_A,GFint_A],WriteMax,WriteStep,header,filename)
	if WriteVertex:
		filename = 'vertex_'+str(GFtype)+'_U'+str(U)+'eps'+str(ed)+'T'+str(T)+'.dat'
		header = '# E\t\tRe Bubble\t\tIm Bubble\t\tRe K\t\tIm K\t\tRe SD-kernel\t\tIm SD-kernel'
		WriteFileX([Bubble_A,K_A,ChiGamma_A],WriteMax,WriteStep,header,filename)
	if WriteNpz:
		sp.savez_compressed('siam',En_A = En_A, GFzero_A = GFzero_A, GFint_A = GFint_A, SE_A = SE_A, Lambda = Lambda, SigmaT = SigmaT)
		if chat: print('# File siam.npz written.')

if chat: print('# '+argv[0]+' DONE after {0: .2f} seconds.'.format(float(time()-t)))

## siam_parquet.py end ###

