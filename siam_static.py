# simplified parquet equation solver for SIAM
# using brentq to solve the self-consistent equation
# generalized for the charge non-symmetric case and finite temperatures
# uses scipy, optimized on python 3.5.2 and SciPy 0.18
# Vladislav Pokorny; 2015-2017; pokornyv@fzu.cz

import scipy as sp
from scipy.optimize import brentq
from sys import argv,exit,version_info
#from scipy.interpolate import InterpolatedUnivariatepline
from time import ctime,time
from parlib import *
import params_siam as p

t = time()

U      = float(argv[1])
Delta  = float(argv[2])
ed     = float(argv[3])
try:
	T  = float(argv[4])
except IndexError:
	T  = 0.0

izero = 1e-6

# energy axis #############################################
# RuntimeWarning: invalid value encountered in power: 
# for KK we need range(N)**3, for large arrays it can hit the limit of
# 9223372036854775808 == 2**63 of signed int, decrease number of energy points
N = 2**p.NE-1
dE_dec = int(-sp.log10(p.dE))
En_F = FillEnergies(p.dE,N)

hashes = '#'*80

# print the distributions
#for i in range(len(En_F)):
#FD_F = FermiDirac(En_F,T)
#BE_F = BoseEinstein(En_F,T)
#	print('{0: .5f}\t{1: .8f}\t{2: .8f}'.format(En_F[i],float(FD_F[i]),float(BE_F[i])))
#exit()

## print the header #######################################
ver = str(version_info[0])+'.'+str(version_info[1])+'.'+str(version_info[2])
if p.chat: 
	print (hashes+'\n# generated by '+str(argv[0])+', python version: '+str(ver)+', SciPy version: '\
           +str(sp.version.version)+', '+str(ctime()))
	print('# energy axis: [{0: .5f} ..{1: .5f}], step = {2: .5f}, length = {3: 3d}'\
      .format(En_F[0],En_F[-1],p.dE,len(En_F)))
	print('# U = {0: .4f}, Delta = {1: .4f}, ed = {2: .4f}, T = {3: .4f}'.format(U,Delta,ed,T))
	print("# Kondo temperature Tk ~{0: .5f}".format(float(KondoTemperature(U,Delta,ed))))

## inicialize the non-interacting Green function ##########
if p.GFtype == 'lor':
	if p.chat: print('# using Lorentzian non-interacting DoS')
	GFlambda = lambda x: GreensFunctionLorenz(x,Delta)
	DensityLambda = lambda x: DensityLorentz(x,Delta)
elif p.GFtype == 'semi':
	if p.chat: print('# using semielliptic non-interacting DoS')
	W = Delta # half-bandwidth 
	GFlambda = lambda x: GreensFunctionSemi(x,W)
	DensityLambda = lambda x: DensitySemi(x,W)
elif p.GFtype == 'gauss':
	if p.chat: print('# using Gaussian non-interacting DoS')
	GFlambda = lambda x: GreensFunctionGauss(x,Delta)
	DensityLambda = lambda x: DensityGauss(x,Delta)
elif p.GFtype == 'sc':
	if p.chat: print('# using simple cubic lattice non-interacting DoS')
	W = Delta # half-bandwidth 
	GFlambda = lambda x: GreensFunctionSC(x,W)
elif p.GFtype == 'sq':
	if p.chat: print('# using square lattice non-interacting DoS')
	W = Delta # half-bandwidth 
	GFlambda = lambda x: GreensFunctionSquare(x,izero,W)
else:
	print('# Error: DoS not implemented.')
	exit(1)

if p.chat: print('# filling the array with the non-interacting Green function...')
if p.GFtype in ['sc','sq']:
	fin = p.GFtype+'_gf_'+str(W)+'_'+str(p.NE)+'_'+str(p.dE)+'.npz'
	try:
		GFzero_F = sp.load(fin)['GFzero_F']
		i2 = sp.load(fin)['izero']
		if i2 == izero:
			if p.chat: print('# - reading non-interacting GF from file '+fin)
		else: 
			print('- i0 value differs from the saved data')
			raise FileNotFoundError()
	except FileNotFoundError:
		if p.chat: print('# - file '+fin+' not found, or i0 differs, generating new file')
		t = time()
		GFzero_F = GFlambda(En_F)
		GFzero_F = GFzero_F/IntDOS(GFzero_F,En_F)
		sp.savez_compressed(fin, En_F = En_F, GFzero_F = GFzero_F, izero = izero)
		if p.chat: print('# - file generated in '+str(int(time()-t))+' seconds.')
else:		
	GFzero_F = GFlambda(En_F)
	GFzero_F = GFzero_F/IntDOS(GFzero_F,En_F)
#WriteFile(En_F,GFzero_F,GFzero_F,GFzero_F,U,Delta,ed,p.WriteMax,p.WriteStep,'gf','GFzero.dat',p.chat)

## calculating the charge-symmetric case (n=0.5) to get Lambda0
if p.chat: print('#\n# calculating the charge-symmetric solution:')
if p.chat: print('# norm[G0]: {0: .6f}, n[G0]: {1: .6f}'\
.format(float(IntDOS(GFzero_F,En_F)),float(Filling(GFzero_F,En_F,T))))

if p.chat: print('# calculating the charge-symmetric two-particle bubble...')
Bubble_F = TwoParticleBubble(GFzero_F,GFzero_F,En_F,T,'eh') # Bubble[0] is negative
BubZero = Bubble_F[int(N/2)]
Uc = -1.0/sp.real(BubZero)
if p.chat: print('# - Bubble[0] = {0: .6f},   critical U = {1: .6f}'.format(BubZero,Uc))
if p.chat: print('# calculating the charge-symmetric Lambda vertex...')
Lambda = CalculateLambda(U,Bubble_F,GFzero_F,GFzero_F,En_F,T,p.chat,p.epsl)
if p.chat: print('# - Lambda = {0: .6f}'.format(Lambda))

SigmaT = SigmaT_old = -ed
GFtherm_F = sp.copy(GFzero_F)
nT = 0.5
k = 1
## calculating the non-charge-symmetric case ##############
if ed!=0.0:
	nTold = 1e5
	Lambdaold = 1e5
	if p.chat: print('#\n# calculating the non-symmetric solution:')
	if p.chat: print('# iterating the thermodynamic self-energy SigmaT, mixing: alpha = {0: .3f}:'.format(float(p.alpha)))
	while any([sp.fabs(nT-nTold)>p.epst,sp.fabs(SigmaT-SigmaT_old)>p.epst]):
		nTold = nT
		Lambdaold = Lambda
		SigmaT_old = SigmaT
		if p.GFtype in ['sc','sq']: GFtherm_F = ShiftGreensFunction(GFzero_F,En_F,-ed-SigmaT)
		else:                       GFtherm_F = GFlambda(En_F-ed-SigmaT)
		Bubble_F = TwoParticleBubble(GFtherm_F,GFtherm_F,En_F,T,'eh') # Bubble[0] is negative
		Lambda = CalculateLambda(U,Bubble_F,GFtherm_F,GFtherm_F,En_F,T,p.chat,p.epsl)
		## calculate nT ###################################
		if p.GFtype in ['lor','semi','gauss']:
			if T == 0.0: # zero-temperature data can be calculated more precisely
				eq = lambda x: DensityLambda(ed+Lambda*(x-0.5)) - x
			else: # finite temperature
				eq = lambda x: Filling(GFlambda(En_F-ed-Lambda*(x-0.5)),En_F,T) - x
		elif p.GFtype in ['sc','sq']:
			eq = lambda x: Filling(ShiftGreensFunction(GFzero_F,En_F,-ed-Lambda*(x-0.5)),En_F,T) - x
		else:
			if p.chat: print('# Error: unknown density of states.')
			exit()
		try:
			nT = brentq(eq,0.0,1.0,xtol = p.epst)
		except ValueError:	# we have full or empty band, it can cause "f(a) and f(b) must have different signs" error
			print('# Warning: nT cannot be evaluated, assuming full/empty band')
			nT = 0.0 if ed > 0.0 else 1.0
		## calculate SigmaT ###############################
		SigmaT = Lambda*(nT-0.5)
		if p.chat: print('# - iteration {0: 3d}: norm[GTin] = {1: .6f}, n[GTin] = {2: .6f}, Lambda = {3: .6f}, nT = {4: .6f}, SigmaT = {5: .6f}'\
		.format(int(k),float(IntDOS(GFtherm_F,En_F)),float(Filling(GFtherm_F,En_F,T)),Lambda,float(nT),float(SigmaT)))
		k+=1
		SigmaT = p.alpha*SigmaT+(1.0-p.alpha)*SigmaT_old	# mix iterations, useful far away from half-filling
	if p.chat: print('# Calculation of SigmaT finished after {0: 3d} iterations.'.format(int(k-1)))

## recalculate the thermodynamic Green function and bubble, just in case
if p.GFtype in ['sc','sq']: GFtherm_F = ShiftGreensFunction(GFzero_F,En_F,-ed-SigmaT)
else:                       GFtherm_F = GFlambda(En_F-ed-SigmaT)
Bubble_F = TwoParticleBubble(GFtherm_F,GFtherm_F,En_F,T,'eh')
BubZero = Bubble_F[int(N/2)]
Lambda = CalculateLambda(U,Bubble_F,GFtherm_F,GFtherm_F,En_F,T,p.chat,p.epsl)
if p.chat: print('# final parameters: Bubble[0] = {0: .6f}, Lambda = {1: .6f}, nT = {2: .6f}, SigmaT = {3: .6f}, muBar = {4: .6f}'\
.format(BubZero,Lambda,float(nT),float(SigmaT),float(-SigmaT-ed)))

## calculate the spectral self-energy and Green function ##
if p.chat: print('#\n# calculating the spectral self-energy...')
K_F = KVertex(Lambda,Bubble_F)
ChiGamma_F = U*Bubble_F*(K_F + Lambda)
SE_F = SelfEnergy(GFtherm_F,ChiGamma_F,En_F,T)

## asymptotic formula for vertex K in strong coupling limit
#Kasymp_F = Lambda/(1.0+Lambda*(Bubble_F[int(N/2)]-1.0j*(En_F+1e-12j)/sp.pi))

## quasiparticle weight ###################################
[Z,dReSEdw] = QuasiPWeight(En_F,sp.real(SE_F))

if p.chat: print('# - Z = {0: .6f}, DReSE/dw[0] = {1: .6f}, m*/m = {2: .6f}'\
.format(float(Z),float(dReSEdw),float(1.0/Z)))

## calculating interacting Green function #################
if p.chat: print('# calculating the spectral function and final filling')
if p.GFmethod == "H": ## this is the local GF as a sum over the Brillouin zone
	if ed!=0.0:
		if p.chat: print('# iterating the final density n=fx[G(n)]...')
		eq = lambda x: x - Filling(GFlambda(En_F-ed-U*(x-0.5)-SE_F),En_F,T)
		n = brentq(eq,0.0,1.0,xtol = p.epsn)
	else: n = 0.5
	GFint_F = GFlambda(En_F-ed-U*(n-0.5)-SE_F)
else: ## this calculates the lattice Green function from the Dyson equation
	if ed!=0.0:
		if p.chat: print('# iterating the final density n=fx[G(n)]...')
		eq = lambda x: x - Filling(1.0/(1.0/GFtherm_F-U*(x-0.5)-SE_F),En_F,T)
		n = brentq(eq,0.0,1.0,xtol = p.epsn)
	else: n = 0.5
	GFint_F = 1.0/(1.0/GFtherm_F-U*(n-0.5)-SE_F)

n = Filling(GFint_F,En_F,T)
if p.chat: print('# - ed = {0: .6f}: norm[Gint] = {1: .6f}, n[Gint] = {2: .6f}'.format(ed,float(IntDOS(GFint_F,En_F)),float(n)))

'''
## non-local susceptibilities #############################
muBar = -(SigmaT+ed)
DoSmuBar = -sp.imag(GFlambda(muBar))/sp.pi
AFBubble = AFbubble(En_F,GFzero_F,muBar,T)
FBubble  = -DoSmuBar
print('{0: .3f}\t{1: .4f}\t{2: .3f}\t{3: .5f}\t{4: .5f}\t{5: .8f}\t{6: .8f}\t{7: .8f}\t{8: .8f}'\
.format(float(U),float(ed),float(T),float(n),float(nT),float(AFBubble),float(FBubble),float(1.0+Lambda*AFBubble),float(1.0+Lambda*FBubble)))
exit()
'''

## DoS at Fermi energy ####################################
DOSF = -sp.imag(GFint_F[int(N/2)])/sp.pi

## Kondo scale from Lambda ################################
a = 1.0 + Lambda*sp.real(BubZero)

## HWHM ###################################################
[HWHM,DOSmax,wmax] = CalculateHWHM(GFint_F,En_F)
if HWHM == 0.0 and p.chat: print('# Warning: HWHM cannot be calculated, setting it to zero.')
if HWHM < p.dE and HWHM != 0.0: print('# - Warning: HWHM smaller than energy resolution.')

if p.chat: print('# - DOS[0] = {0: .6f}, maximum of DoS: {1: .6f} at w = {2: .6f}'.format(float(DOSF),float(DOSmax),float(wmax)))
if p.chat: print('# - Kondo scales: a = {0: .6f}, exp(-U DOS[0]) = {1: .6f}, HWHM = {2: .6f}'\
.format(float(a),float(sp.exp(-U*DOSF)),float(HWHM)))
if HWHM < p.dE and HWHM != 0.0: print('# - Warning: HWHM smaller than energy resolution.')

## susceptibilities #######################################
if p.calcSusc:
	if p.chat: print('# calculating susceptibilities:')
	[X1_F,X2_F,X3_F] = XIntegralsFFT(GFtherm_F,Bubble_F,Lambda,BubZero,T,En_F)
	X_F = X1_F+X2_F+X3_F
	XT = SusceptibilityTherm(a,GFtherm_F,En_F,T)
	XS = SusceptibilitySpec(U,Lambda,X_F,GFint_F,BubZero,En_F,T)
	XH = SusceptibilityHF(U,GFint_F,X_F,En_F,T)

	if p.chat: print('# - Thermal  susceptibility: XT = {0: .5f}\n\
# - Spectral susceptibility: XS = {1: .5f}\n\
# - Hartree  susceptibility: XH = {2: .5f}'.format(float(XT),float(XS),float(XH)))
else:
	if p.chat: print('# susceptibilities are not calculated')
	XT = XS = XH = 0.0

print('{0: .3f}\t{1: .3f}\t{2: .4f}\t{3: .5f}\t{4: .5f}\t{5: .5f}\t{6: .5f}\t\
{7: .6f}\t{8: .6f}\t{9: .6f}\t{10: .5f}\t{11: .5f}\t{12: .5f}'\
.format(U,ed,T,nT,n,Lambda,float(a),float(DOSF),float(Z),float(HWHM),float(XT),float(XS),float(XH)))

## write the outputs ######################################
if any([p.WriteGF,p.WriteVertex,p.WriteNpz]):
	if p.chat: print('# writing the output files:')
	ed = sp.around(ed,3)
	#if p.calcSusc:
	#	filename = 'X_'+p.GFtype+'_U'+str(U)+'.dat'
	#	header = '# E\t\t\tRe X1\t\tIm X1\t\tRe X2\t\tIm X2\t\tRe X3\t\tIm X3\n'
	#	WriteFile(En_F,X1_F,X2_F,X3_F,U,Delta,ed,p.WriteMax,p.WriteStep,header,filename,p.chat)
	if p.WriteGF:
		filename = 'gf_'+str(p.GFtype)+'_U'+str(U)+'eps'+str(ed)+'T'+str(T)+'.dat'
		header = '# E\t\t\tRe GF0\t\tIm GF0\t\tRe SE\t\tIm SE\t\tRe GF\t\tIm GF\n'
		WriteFile(En_F,GFtherm_F,SE_F,GFint_F,U,Delta,ed,p.WriteMax,p.WriteStep,header,filename,p.chat)
	if p.WriteVertex:
		filename = 'vertex_'+str(p.GFtype)+'_U'+str(U)+'eps'+str(ed)+'T'+str(T)+'.dat'
		header = '# E\t\t\tRe Bubble\t\tIm Bubble\t\tRe K\t\tIm K\t\tRe SD-kernel\t\tIm SD-kernel\n'
		WriteFile(En_F,Bubble_F,K_F,ChiGamma_F,U,Delta,ed,p.WriteMax,p.WriteStep,header,filename,p.chat)
	if p.WriteNpz:
		sp.savez_compressed('siam',En_F = En_F, GFzero_F = GFzero_F, GFint_F = GFint_F, SE_F = SE_F, Lambda = Lambda, SigmaT = SigmaT)
		if p.chat: print('# File siam.npz written.')

if p.chat: print('# '+argv[0]+' DONE after {0: .2f} seconds.'.format(float(time()-t)))

## siam_parquet.py end ###

